[TOC]



## 从明文通信到对称加密

### 明文通信

为什么要加密呢？不妨先看看明文通信

![未加密的危险](http://lighklife.github.io/img/2018/2018-3-未加密的危险.png)

Eve 可以直接窃听到Alice与Bob的通信过程，通过抓包就可以查看到通信内容，如果邮件内容是羞答答的，怎么可以被其他人看到呢？（邪魅微笑）

在逼格满满的咖啡厅，你正在愉快的刷着微博，逛着知乎，浏览豆瓣，你以为你连着免费WiFi爽歪歪，

图，喝咖啡，玩手机

然后其实被他笔记本造的WiFi，

图，黑客



顺便一提，关于抓包，现成的抓包工具很多，如 [wireshark](https://www.wireshark.org/)，[charles](https://www.charlesproxy.com/) 等，这里有一篇使用charles抓APP包的文章，要不要 [看看](https://lighklife.github.io/2017/08/15/2017/Https%E6%8A%93%E5%8C%85/)

### 开始加密

#### 凯撒密码（字母代换）

![凯撒密码.jpg](http://upload-images.jianshu.io/upload_images/3983351-1da3a5ef1c198468.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

将一个字母表向指定方向平移N位，解密反之，N为密钥 。

> 密钥只可能是0-25共26个，用1-25每个数作为密钥尝试解密，很容易发现明文，从而得出密钥是几。（暴力破解）

#### 简单替换密码

![简单替换密码.jpg](http://upload-images.jianshu.io/upload_images/3983351-1fcc70aec5f4f862.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

两个字母表中字母之间随机一一对应， 密钥是替换表。

> 密钥空间是 26！= 2^88。所以考虑使用（频率破解）。

####  对称密码标准
- DES（Data Encryption Standard）（不再推荐）
- AES（Advanced Encryption Standard） （应该使用）

`AES` 目前采用的是`Rijndael` 算法，`Rijndael` 的分组长度可以是以32bit为单位在128到256范围内选择。目前AES 规定分组长度只能有128,192,256三种。

AES 一轮的步骤：

- 加密：SubBytes ---> ShiftRows ---> MixColumns ---> AddRoundKey
- 解密：AddRoundKey ---> InvMixColumns ---> InvShiftRows ---> InvSubBytes

其中步骤的含义为：

1. SubBytes： 每个字节的值（0-255的任意值）为索引，从一张拥有256个值的替换表（S-Box）中查找对应的值处理。将一个1字节的值替换成另一个1字节的值。
2. ShiftRows：将4个字节为单位的行（Row）按照一定的规则左平移。
3. MixColumns：将一个4字节的值进行比特运算，变成另一个4字节的值。
4. AddRoundKey ：将MixColumns的输出与轮密钥XOR。

### 对称加密

Alice 和 Bob 使用相同的秘钥来加解密消息，也就是**对称加密**，上面提到的加密算法都是对称加密。

![对称加密图示](http://lighklife.github.io/img/2018/2018-3-对称加密图示.png)

这样，即使第三者 Eve 窃听到通信过程，那么 Eve 也只能看到奇奇怪怪符号组成的密文

![加密之后的情况](http://lighklife.github.io/img/2018/2018-3-加密之后的情况.png)

这样Alice和Bob就可以放心的互相通信了吗？对啊！当然不是，这只是解决了机密性的问题，对称加密的密钥需要被发送给对方，对方才能解密，但直接发送，秘钥也会被窃听，这就是秘钥配送问题。

![存在的缺陷](http://lighklife.github.io/img/2018/2018-1-%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%9A%84%E7%BC%BA%E9%99%B7.PNG)



### 解决秘钥配送

* 事先当面将秘钥给对方，不通过网络传输秘钥，避免了被窃听的机会；
* 通过密钥分配中心解决；
* 通过 Diffie-Hellman 密钥交换来解决；
* 通过公钥密码来解决。

![Diffie-Hellman](http://lighklife.github.io/img/2017/Diffie-Hellman.png)

## 公钥加密

### 简述

公钥加密又叫非对称加密，这类加密算法中存一对秘钥：

- 公钥——用来加密信息，公开给任何人
- 私钥——用来解密信息，自己私藏

公钥和私钥匙是天生一对，一个确定的公钥加密的信息，只有他的私钥才能解密信息。

![公钥加密样式](http://lighklife.github.io/img/2018/2018-3-公钥加密样式.png)

使用公钥加密对信息进行加密通信的流程如下：



![公钥加密](http://lighklife.github.io/img/2018/2018-3-公钥加密.png)

### 公钥算法——RSA

RSA是一种非对称加密算法，是1977年由[罗纳德·李维斯特](https://zh.wikipedia.org/wiki/%E7%BD%97%E7%BA%B3%E5%BE%B7%C2%B7%E6%9D%8E%E7%BB%B4%E6%96%AF%E7%89%B9)（Ron Rivest）、[阿迪·萨莫尔](https://zh.wikipedia.org/wiki/%E9%98%BF%E8%BF%AA%C2%B7%E8%90%A8%E8%8E%AB%E5%B0%94)（Adi Shamir）和[伦纳德·阿德曼](https://zh.wikipedia.org/wiki/%E4%BC%A6%E7%BA%B3%E5%BE%B7%C2%B7%E9%98%BF%E5%BE%B7%E6%9B%BC)（Leonard Adleman）一起提出的，并以他们名字的首字母命名。

| name | VALUE |
| :------- | :----------- |
| **秘钥** | 数 E 和 数 N |
| **秘钥** | 数 D 和 数 N |
|   **加密过程**   | $$ 密文 = (明文^E) mod(N )$$ |
|   **解密过程**   | $$ 明文 = (密文^D) mod (N )$$ |

![RSA加密](http://lighklife.github.io/img/2017/RSA%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86.jpg)
原理详情：

[阮一峰的网络日志——RSA算法原理（一）](http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html)

[阮一峰的网络日志——RSA算法原理（二）](http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html)

### 缺陷
加密运算强度大，费时间，比如RSA加密过程是对明文求指数运算后再取模，这显然比AES运算量要大。有何优化方案吗？有，结合对称加密与公钥加密。

##混合密码系统

### 加密

![混合加密](http://lighklife.github.io/img/2018/2018-3-混合加密.png)

### 解密

![混合密码解密](http://lighklife.github.io/img/2018/2018-3-混合密码解密.png)

## 单向散列函数——文件被修改了吗？

### 概述

网络下载软件，或者传输文件，如何验证没有被第三方篡改呢？即是数据的的**完整性**（intergrity），也称**一致性**。

![确认文件的完整性](http://lighklife.github.io/img/2018/2018-3-确认文件的完整性.png)

### 

单项散列函数就是生成文件“指纹”的方法。单项散列函数也称为消息摘要函数(`message digest function`)，哈希函数，杂凑函数。

![单向散列函数确保文件一致性](http://lighklife.github.io/img/2018/2018-3-单向散列函数确保文件一致性.png)

### 性质

1. 根据任意长度的消息计算出固定长度的散列值。
2. 能快速计算出散列值。
3. 抗碰撞性，消息不同，散列值也不同。
4. 具备单向性,根据散列值无法计算出消息。

![散列值长度固定](http://lighklife.github.io/img/2018/2018-3-散列值长度固定.png)

### 举例

#### MD5

MD5(Message Digest)：一般128位的MD5散列被表示为32位十六进制数字，例如

```9e107d9d372bb6826bd81d3542a419d6 = MD5("The quick brown fox jumps over the lazy dog");```

其强抗碰撞性已经被攻破，已经不再安全。

#### SHA-1/2/3 (Secure Hash Algorithm)

sha1: 已经被列为“可谨慎运用的密码清单”，为了保持兼容性才使用；其强抗碰撞性已经 [被攻破](https://www.zhihu.com/question/56234281)。

sha2：由 SHA-256 和 SHA-512衍生出6种版本，显然鉴于内部状态，SHA-256系列更适合32位CPU。

| 名称        | 输出长度 | 内部状态长度 | 备注                       |
| ----------- | -------- | ------------ | -------------------------- |
| SHA-224     | 224      | 32 * 8 = 256 | 将SHA-256的结果截掉32比特  |
| SHA-256     | 256      | 32 * 8 = 256 |                            |
| SHA-521/224 | 224      | 64 * 8 = 512 | 将SHA-512的结果截掉288比特 |
| SHA-512/256 | 256      | 64 * 8 = 512 | 将SHA-512的结果截掉256比特 |
| SHA-384     | 384      | 64 * 8 = 512 | 将SHA-512的结果截掉128比特 |
| SHA-512     | 512      | 64 * 8 = 512 |                            |

sha3：2012年选拔出名为Keccak的算法作为sha3，结构完全不同sha-2，适用各种设备，硬件上实现性能高，更安全。

### 不能解的问题

使用单向散列函数能实现完整性的检察，但是有些如果主动攻击者Mallory伪装成Alice，向Bob同时发送了消息和散列值。这时Bob能通过单向散列函数检察消息的完整性，但是却没能识别出这条消息是Mallory**伪装**成Bob发送的，无法被认证。

## 消息认证码——消息是伪装者发的吗？
消息认证码（Message Authentication Code） 是一种与密钥相关联的单项散列函数。

 ![hash与MAC](http://lighklife.github.io/img/2017/hash与MAC.jpg)

* 要计算MAC值必须持有共享密钥，MAC正是利用这一性质确认完整性的。


* 只有通信双方才能持有共享密钥，密钥配送问题可以使用公钥密码，Diffie-Hellman密钥交换，密钥分配中心等来解决。

![消息认证码](http://lighklife.github.io/img/2018/2018-3-消息认证码.png)

### 无法解决的问题

重放攻击

![重放攻击](http://lighklife.github.io/img/2018/2018-3-重放攻击.png)

消息认证码解决了完整性与伪装问题，仍然无法解决“对第三方证明”和“防否认”问题。这就需要数字签名来解决。

## 数字签名——消息到底是谁写的
### 概述
 设想要防否认，只要签名只能由消息发送者生产就OK了。

 数字签名对签名者的秘钥和验证者的秘钥进行了区分，使用验证签名无法生产签名。签名秘钥只由签名者持有。

 这和公钥密码有点相似了。事实上，签名就是公钥密码“反过来”实现的。
 对于消息签名，速度太慢，因为每个消息的散列值是不一样的，所以一般只需要对消息的散列值进行签名就可以了。

![签名时间图](http://lighklife.github.io/img/2018/2018-3-签名时间图.png)

### 应用举例

  1. 信息安全公告。
  2. 软件下载。
  3. 公钥证书。(得到合法的公钥)
  4. SSL/TLS。


### 无法解决的问题
 通过对散列值签名我们可以解决完整性，篡改，伪造问题，但是用于验证签名的公钥是否是真正的发送者的呢？中间人可以用自己的私钥签名，并把自己的公钥发送给接受者。
 为验证公钥是否合法，我们需要使用证书。

## 证书——公钥合法了
证书就是我们信任的第三方对发送者的公钥加上了他们的数字签名。相当于身份证一样的东西。这里的第三方包括例如赛门铁客等机构，也可以是自己组织内部成立的一个机构。

证书主要包含：

  1. 证书序号。
  2. 证书颁发机构。
  3. 公钥所有者。
  4. SHA-1 指纹。
  5. MD５指纹。
  6. 证书ID。
  7. 有效期起始时间。
  8. 有效期结束时间。
  9. 散列算法。
  10. 秘钥ID。
  11. 秘钥用途。